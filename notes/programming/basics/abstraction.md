
# Abstraction

Abstraction is a fundamental concept of programming which involves simplifying complex systems and breaking them down into smaller, more manageable parts. It also involves hiding unnecessary details about the implementation of a feature and only exposing relevant and required information. It is one of the most important and essential principles of [object-oriented programming](object_oriented_programming.md).

Abstraction is based on the principle that a user does not need to know every detail about the implementation of a feature, in reality he only has to know how to use it. This allows to hide this unnecessary information from the user. This allows programmers to work with higher-level representations of data and functionality rather than having to deal with lower-level implementations.

## Advantages

- Abstraction can simplify the process of [problem solving](problem_solving.md) by allowing to focus on the essential aspects of the problem while ignoring the unimportant details.
- Abstraction often goes hand-in-hand with [encapsulation](encapsulation.md), which refers to the bundling of data and methods into a class. Abstraction allows to only expose necessary interfaces of the class while hiding irrelevant information about its inner workings.
- Abstraction encourages modular development by dividing complex systems into smaller, independent modules.
- Abstraction helps creating reusable components or classes that can be used in different parts of a project or even in a completely different project without having to worry about implementation.

## Disadvantages

- Many layers of abstraction can lead to increased complexity by making it harder to understand how everything fits together.
- Because of the hidden implementation, the abstraction may have unknown function calls, which may cause performance overhead.
- High abstraction can make debugging more difficult, because important details needed to diagnose and fix the problem may be hidden away.
- Unnecessary levels of abstraction can lead to over-engineering, where the code base becomes overly complex and difficult to maintain.